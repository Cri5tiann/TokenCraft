import java_cup.runtime.*;

/* Terminal tokens */
terminal FUNCTION, IF, ELSE, FOR, RETURN, TRUE, FALSE;
terminal PLUS, MINUS, TIMES, DIVIDE, MOD;
terminal INCREMENT, DECREMENT;
terminal ASSIGN, EQUALS, OR, AND;
terminal LESSEQUAL, GREATEREQUAL, LESS, GREATER;
terminal LPAREN, RPAREN, LBRACE, RBRACE;
terminal SEMICOLON, COMMA;
terminal INPUT_INT, OUTPUT_INT;
terminal String IDENTIFIER;
terminal Integer INTEGER_LITERAL;

/* Non-terminals */
non terminal program, function_declaration, statement_list, statement;
non terminal expression, term, factor;

/* Precedences */
precedence left OR;
precedence left AND;
precedence left EQUALS;
precedence left LESS, LESSEQUAL, GREATER, GREATEREQUAL;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MOD;
precedence right INCREMENT, DECREMENT;
precedence left ELSE;   // Add precedence for ELSE to resolve the dangling else

/* Start with the program */
start with program;

/* Grammar rules */
program ::= function_declaration:f
    {:
        RESULT = new Node("Program");
        ((Node) RESULT).addChild((Node) f);
    :};

function_declaration ::= FUNCTION IDENTIFIER:id LPAREN RPAREN LBRACE statement_list:sl RBRACE
    {:
        RESULT = new Node("Function: " + id);
        ((Node) RESULT).addChild((Node) sl);
    :};

statement_list ::= statement:s
    {:
        System.out.println("Adding statement: " + s);
        RESULT = new Node("Statement List");
        ((Node) RESULT).addChild((Node) s);
    :}
    | statement_list:sl statement:s
    {:
        System.out.println("Adding statement to list: " + s);
        RESULT = sl;
        ((Node) RESULT).addChild((Node) s);
    :};

statement ::= expression:e SEMICOLON
    {:
        RESULT = new Node("Statement");
        ((Node) RESULT).addChild((Node) e);
    :}
    | IF LPAREN expression:e RPAREN statement:s
    {:
        RESULT = new Node("If Statement");
        ((Node) RESULT).addChild((Node) e);
        ((Node) RESULT).addChild((Node) s);
    :}
    | IF LPAREN expression:e RPAREN statement:s1 ELSE statement:s2
    {:
        RESULT = new Node("If-Else Statement");
        ((Node) RESULT).addChild((Node) e);
        ((Node) RESULT).addChild((Node) s1);
        ((Node) RESULT).addChild((Node) s2);
    :}
    | FOR LPAREN expression:e1 SEMICOLON expression:e2 SEMICOLON expression:e3 RPAREN statement:s
    {:
        RESULT = new Node("For Loop");
        ((Node) RESULT).addChild((Node) e1);
        ((Node) RESULT).addChild((Node) e2);
        ((Node) RESULT).addChild((Node) e3);
        ((Node) RESULT).addChild((Node) s);
    :}
    | RETURN expression:e SEMICOLON
    {:
        RESULT = new Node("Return");
        ((Node) RESULT).addChild((Node) e);
    :}
    | RETURN SEMICOLON
    {:
        RESULT = new Node("Return Void");
    :};

expression ::= term:t
    {:
        RESULT = t;
    :}
    | expression:e PLUS term:t
    {:
        RESULT = new Node("+");
        ((Node) RESULT).addChild((Node) e);
        ((Node) RESULT).addChild((Node) t);
    :}
    | expression:e MINUS term:t
    {:
        RESULT = new Node("-");
        ((Node) RESULT).addChild((Node) e);
        ((Node) RESULT).addChild((Node) t);
    :}
    | expression:e LESS term:t
    {:
        RESULT = new Node("<");
        ((Node) RESULT).addChild((Node) e);
        ((Node) RESULT).addChild((Node) t);
    :}
    | expression:e LESSEQUAL term:t
    {:
        RESULT = new Node("<=");
        ((Node) RESULT).addChild((Node) e);
        ((Node) RESULT).addChild((Node) t);
    :}
    | expression:e GREATER term:t
    {:
        RESULT = new Node(">");
        ((Node) RESULT).addChild((Node) e);
        ((Node) RESULT).addChild((Node) t);
    :}
    | expression:e GREATEREQUAL term:t
    {:
        RESULT = new Node(">=");
        ((Node) RESULT).addChild((Node) e);
        ((Node) RESULT).addChild((Node) t);
    :}
    | expression:e EQUALS term:t
    {:
        RESULT = new Node("==");
        ((Node) RESULT).addChild((Node) e);
        ((Node) RESULT).addChild((Node) t);
    :}
    | expression:e AND term:t
    {:
        RESULT = new Node("&&");
        ((Node) RESULT).addChild((Node) e);
        ((Node) RESULT).addChild((Node) t);
    :}
    | expression:e OR term:t
    {:
        RESULT = new Node("||");
        ((Node) RESULT).addChild((Node) e);
        ((Node) RESULT).addChild((Node) t);
    :}
    | IDENTIFIER:id ASSIGN expression:e
    {:
        RESULT = new Node("=");
        ((Node) RESULT).addChild(new Node(id));
        ((Node) RESULT).addChild((Node) e);
    :}
    | IDENTIFIER:id INCREMENT
    {:
        RESULT = new Node("++");
        ((Node) RESULT).addChild(new Node(id));
    :}
    | IDENTIFIER:id DECREMENT
    {:
        RESULT = new Node("--");
        ((Node) RESULT).addChild(new Node(id));
    :}
    | TRUE
    {:
        RESULT = new Node("true");
    :}
    | FALSE
    {:
        RESULT = new Node("false");
    :};

term ::= factor:f
    {:
        RESULT = f;
    :}
    | term:t TIMES factor:f
    {:
        RESULT = new Node("*");
        ((Node) RESULT).addChild((Node) t);
        ((Node) RESULT).addChild((Node) f);
    :}
    | term:t DIVIDE factor:f
    {:
        RESULT = new Node("/");
        ((Node) RESULT).addChild((Node) t);
        ((Node) RESULT).addChild((Node) f);
    :}
    | term:t MOD factor:f
    {:
        RESULT = new Node("%");
        ((Node) RESULT).addChild((Node) t);
        ((Node) RESULT).addChild((Node) f);
    :};

factor ::= INTEGER_LITERAL:i
    {:
        RESULT = new Node(i.toString());
    :}
    | IDENTIFIER:id
    {:
        RESULT = new Node(id);
    :}
    | LPAREN expression:e RPAREN
    {:
        RESULT = e;
    :}
    | INPUT_INT LPAREN RPAREN
    {:
        RESULT = new Node("input_int()");
    :}
    | OUTPUT_INT LPAREN expression:e RPAREN
    {:
        RESULT = new Node("output_int");
        ((Node) RESULT).addChild((Node) e);
    :};

import java_cup.runtime.*;

/* Terminal tokens */
terminal FUNCTION, IF, ELSE, FOR, RETURN, TRUE, FALSE;
terminal PLUS, MINUS, TIMES, DIVIDE, MOD;
terminal INCREMENT, DECREMENT;
terminal ASSIGN, EQUALS, OR, AND;
terminal LESSEQUAL, GREATEREQUAL, LESS, GREATER;
terminal LPAREN, RPAREN, LBRACE, RBRACE;
terminal SEMICOLON, COMMA;
terminal INPUT_INT, OUTPUT_INT;
terminal String IDENTIFIER;
terminal Integer INTEGER_LITERAL;

/* Non-terminals */
non terminal program, function_declaration, statement_list, statement;
non terminal expression, term, factor;
non terminal parameter_list, parameter;

/* Precedences */
precedence left OR;
precedence left AND;
precedence left EQUALS;
precedence left LESS, LESSEQUAL, GREATER, GREATEREQUAL;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MOD;
precedence right INCREMENT, DECREMENT;
precedence left ELSE;   // Add precedence for ELSE to resolve the dangling else

/* Start with the program */
start with program;

/* Grammar rules */
program ::= function_declaration:f
    {:
        System.out.println("Creating Program node");
        RESULT = new Node("Program");
        ((Node) RESULT).addChild((Node) f);
    :};

function_declaration ::= FUNCTION IDENTIFIER:id LPAREN RPAREN LBRACE statement_list:sl RBRACE
    {:
        System.out.println("Creating Function node: " + id);
        RESULT = new Node("Function: " + id);
        ((Node) RESULT).addChild((Node) sl);
    :}
    | FUNCTION IDENTIFIER:id LPAREN parameter_list:pl RPAREN LBRACE statement_list:sl RBRACE
    {:
        System.out.println("Creating Function node with parameters: " + id);
        RESULT = new Node("Function: " + id);
        ((Node) RESULT).addChild((Node) pl);
        ((Node) RESULT).addChild((Node) sl);
    :};

parameter_list ::= parameter:p
    {:
        RESULT = new Node("Parameters");
        ((Node) RESULT).addChild((Node) p);
    :}
    | parameter_list:pl COMMA parameter:p
    {:
        RESULT = pl;
        ((Node) RESULT).addChild((Node) p);
    :};

parameter ::= IDENTIFIER:id
    {:
        RESULT = new Node("Parameter: " + id);
    :};

statement_list ::= statement:s
    {:
        System.out.println("Creating new statement list with single statement");
        Node list = new Node("Statement List");
        list.addChild((Node) s);
        RESULT = list;
    :}
    | statement_list:sl statement:s
    {:
        System.out.println("Adding statement to existing list");
        // Important: Create a new list to avoid reference issues
        Node newList = new Node("Statement List");
        // Copy existing children
        for (Node child : ((Node)sl).getChildren()) {
            newList.addChild(child);
        }
        // Add new statement
        newList.addChild((Node) s);
        RESULT = newList;
    :};

statement ::= expression:e SEMICOLON
    {:
        System.out.println("Creating expression statement");
        RESULT = new Node("Statement");
        ((Node) RESULT).addChild((Node) e);
    :}
    | RETURN expression:e SEMICOLON
    {:
        System.out.println("Creating return statement with expression");
        Node returnNode = new Node("Return");
        returnNode.addChild((Node) e);
        RESULT = returnNode;
    :}
    | RETURN SEMICOLON
    {:
        System.out.println("Creating void return statement");
        RESULT = new Node("Return Void");
    :}
    | IF LPAREN expression:e RPAREN statement:s
    {:
        System.out.println("Creating if statement");
        RESULT = new Node("If Statement");
        ((Node) RESULT).addChild((Node) e);
        ((Node) RESULT).addChild((Node) s);
    :}
    | IF LPAREN expression:e RPAREN statement:s1 ELSE statement:s2
    {:
        System.out.println("Creating if-else statement");
        RESULT = new Node("If-Else Statement");
        ((Node) RESULT).addChild((Node) e);
        ((Node) RESULT).addChild((Node) s1);
        ((Node) RESULT).addChild((Node) s2);
    :}
    | FOR LPAREN expression:e1 SEMICOLON expression:e2 SEMICOLON expression:e3 RPAREN statement:s
    {:
        System.out.println("Creating for loop");
        RESULT = new Node("For Loop");
        ((Node) RESULT).addChild((Node) e1);
        ((Node) RESULT).addChild((Node) e2);
        ((Node) RESULT).addChild((Node) e3);
        ((Node) RESULT).addChild((Node) s);
    :}
    | LBRACE statement_list:sl RBRACE
    {:
        RESULT = sl;
    :};

expression ::= term:t
    {:
        RESULT = t;
    :}
    | expression:e PLUS term:t
    {:
        RESULT = new Node("+");
        ((Node) RESULT).addChild((Node) e);
        ((Node) RESULT).addChild((Node) t);
    :}
    | expression:e MINUS term:t
    {:
        RESULT = new Node("-");
        ((Node) RESULT).addChild((Node) e);
        ((Node) RESULT).addChild((Node) t);
    :}
    | expression:e LESS term:t
    {:
        RESULT = new Node("<");
        ((Node) RESULT).addChild((Node) e);
        ((Node) RESULT).addChild((Node) t);
    :}
    | expression:e LESSEQUAL term:t
    {:
        RESULT = new Node("<=");
        ((Node) RESULT).addChild((Node) e);
        ((Node) RESULT).addChild((Node) t);
    :}
    | expression:e GREATER term:t
    {:
        RESULT = new Node(">");
        ((Node) RESULT).addChild((Node) e);
        ((Node) RESULT).addChild((Node) t);
    :}
    | expression:e GREATEREQUAL term:t
    {:
        RESULT = new Node(">=");
        ((Node) RESULT).addChild((Node) e);
        ((Node) RESULT).addChild((Node) t);
    :}
    | expression:e EQUALS term:t
    {:
        RESULT = new Node("==");
        ((Node) RESULT).addChild((Node) e);
        ((Node) RESULT).addChild((Node) t);
    :}
    | expression:e AND term:t
    {:
        RESULT = new Node("&&");
        ((Node) RESULT).addChild((Node) e);
        ((Node) RESULT).addChild((Node) t);
    :}
    | expression:e OR term:t
    {:
        RESULT = new Node("||");
        ((Node) RESULT).addChild((Node) e);
        ((Node) RESULT).addChild((Node) t);
    :}
    | IDENTIFIER:id ASSIGN expression:e
    {:
        RESULT = new Node("=");
        ((Node) RESULT).addChild(new Node(id));
        ((Node) RESULT).addChild((Node) e);
    :}
    | IDENTIFIER:id INCREMENT
    {:
        RESULT = new Node("++");
        ((Node) RESULT).addChild(new Node(id));
    :}
    | IDENTIFIER:id DECREMENT
    {:
        RESULT = new Node("--");
        ((Node) RESULT).addChild(new Node(id));
    :}
    | TRUE
    {:
        RESULT = new Node("true");
    :}
    | FALSE
    {:
        RESULT = new Node("false");
    :};

term ::= factor:f
    {:
        RESULT = f;
    :}
    | term:t TIMES factor:f
    {:
        RESULT = new Node("*");
        ((Node) RESULT).addChild((Node) t);
        ((Node) RESULT).addChild((Node) f);
    :}
    | term:t DIVIDE factor:f
    {:
        RESULT = new Node("/");
        ((Node) RESULT).addChild((Node) t);
        ((Node) RESULT).addChild((Node) f);
    :}
    | term:t MOD factor:f
    {:
        RESULT = new Node("%");
        ((Node) RESULT).addChild((Node) t);
        ((Node) RESULT).addChild((Node) f);
    :};

factor ::= INTEGER_LITERAL:i
    {:
        System.out.println("Creating integer literal node: " + i);
        RESULT = new Node(i.toString());
    :}
    | IDENTIFIER:id
    {:
        System.out.println("Creating identifier node: " + id);
        RESULT = new Node(id);
    :}
    | LPAREN expression:e RPAREN
    {:
        System.out.println("Creating parenthesized expression");
        RESULT = e;
    :};